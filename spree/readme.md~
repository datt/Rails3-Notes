#Spree

Spree is a full featured commerce platform written for the Ruby on Rails framework. It is designed to make programming commerce applications easier by making several assumptions about what most developers needs to get started.

#Installation

          $ gem install spree
          $ spree install 
          
# Table of Contents
    
* [Custom Authentication in Spree](#custom-authentication-in-spree)
* [Role Management in Spree](#role-management-in-spree)
* [Logic Customization in Spree](#logic-customization-in-spree)
    * [Extending Classes](#extending-classes)
    * [Adding a custom method to the Model](#adding-a-custom-method-to-the-model)
    * [Adding a custom method to the Controller](#adding-a-custom-method-to-the-controller)
* [View Customization in Spree](#view-customization-in-spree)
    * [Using Deface for view customization](#using-deface-for-view-customization)
    * [Replacing entire view templates](#replacing-entire-view-templates)
* [Overriding Spree’s core assets](#overriding-spree’s-core-assets)
    * [Overriding individual CSS styles](#overriding-individual-css-styles)
    * [Overriding entire CSS files](#overriding-entire-css-files)
    * [Overriding individual JavaScript functions](#overriding-individual-javaScript-functions)
    * [Overriding entire JavaScript files](#overriding-entire-javaScript-files)
    * [Overriding images](#overriding-images)
    
# Custom Authentication in Spree

In Demo store we used spree E-Commerce Platform. For admin side authentication we used Rails Devise. Spree already provide Devise for user and admin authentication but we customized spree authentication to achieve different admin roles and their authentication. For this we refereed [Spree Custom Authentication](http://guides.spreecommerce.com/authentication.html)

# Role Management in Spree

Spree by default provide only two major roles (user & admin) but in Demo store we created multiple admin roles (super admin & admin) to achive this spree provide Rails cancan. Using this we customized cancan so that we can manage multiple admin roles with different privileges. For this we refereed [Spree Role Management](http://guides.spreecommerce.com/security.html#authorization)

# Logic Customization in Spree

In Demo store we overridden Spree’s business logic (models, controllers, helpers, etc) as per requirement.

## Extending Classes

Standard practice for including such changes in your application or extension is to create a file within the relevant app/models or app/controllers directory with the original class name with _decorator appended.

* To activate your decorators you need to include the following code in your lib/spree_site.rb or lib/extension_name.rb file:

```Ruby
Dir.glob(File.join(File.dirname(__FILE__), "../app/**/*_decorator*.rb")) do |c|
    Rails.configuration.cache_classes ? require(c) : load(c)
end
```

## Adding a custom method to the Model

* app/models/product_decorator.rb

```Ruby
Spree::Product.class_eval do
    def some_method
        ...
    end
end
```
## Adding a custom method to the Controller

* app/controllers/products_controller_decorator.rb

```Ruby
Spree::ProductsController.class_eval do
    def some_action
        ...
    end
end
```

The exact same format can be used to redefine an existing method.

# View Customization in Spree

View customization allows you to extend or replace any view within a Spree. Their are options available:
* Using Deface for view customization
* Replacing entire view templates

## Using Deface for view customization

Deface is a standalone Rails 3 library that enables you to customize Erb templates without needing to directly edit the underlying view file. Deface allows you to use standard CSS3 style selectors to target any element (including Ruby blocks), and perform an action against all the matching elements.

For example, take the Checkout Registration template, which looks like this:
* app/views/spree/checkout/registration.html.erb

```Ruby
<%= render :partial => 'spree/shared/error_messages', :locals => { :target => @user } %>
<h2><%= t(:registration) %></h2>
<div id="registration" data-hook>
  <div id="account" class="columns alpha eight">
    <!-- TODO: add partial with registration form -->
  </div>
  <% if Spree::Config[:allow_guest_checkout] %>
    <div id="guest_checkout" data-hook class="columns omega eight">
      <%= render :partial => 'spree/shared/error_messages', :locals => { :target => @order } %>
      <h2><%= t(:guest_user_account) %></h2>
      <%= form_for @order, :url => update_checkout_registration_path, :method => :put, :html => { :id => 'checkout_form_registration' } do |f| %>
        <p>
          <%= f.label :email, t(:email) %><br />
          <%= f.email_field :email, :class => 'title' %>
        </p>
        <p><%= f.submit t(:continue), :class => 'button primary' %></p>
      <% end %>
    </div>
  <% end %>
</div>
```

If you wanted to insert some code just before the #registration div on the page you would define an override as follows:

* app/overrides/registration_message.rb

```Ruby
Deface::Override.new(:virtual_path  => "spree/checkout/registration",
                     :insert_before => "div#registration",
                     :text          => "<p>Registration is the future!</p>",
                     :name          => "registration_future")
```

This override **inserts** <p>Registration is the future!</p> **before** the div with the id of “registration”.

Deface currently supports the following actions:
* :remove – Removes all elements that match the supplied selector
* :replace – Replaces all elements that match the supplied selector, with the content supplied
* :insert_after – Inserts content supplied after all elements that match the supplied selector
* :insert_before – Inserts content supplied before all elements that match the supplied selector
* :insert_top – Inserts content supplied inside all elements that match the supplied selector, as the first child
* :insert_bottom – Inserts content supplied inside all elements that match the supplied selector, as the last child
* :set_attributes – Sets (or adds) attributes to all elements that match the supplied selector, expects :attributes option to be passed


